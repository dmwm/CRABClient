#!/usr/bin/env python
"""
This contains the hooks to call the different command plug-ins.
It is not intended to contain any of the CRAB-3 client logic,
it simply:
  - intercepts the CLI options and command
  - loads and calls the specified command
  - exit with the proper exit codes
"""
import json
import logging
import logging.handlers
import os
import sys

from httplib import HTTPException
from optparse import OptionParser, OptionGroup
from socket import error as SocketError

from CRABClient import Handler


def getOptionsLogger(client):
    """
    Get the command to run, the options to pass it and a logger instance
    at appropriate level
    """

    parser = OptionParser( usage = 'Usage: %prog <command> [options]\n\nCRAB 3 RESTful client',
                       description = "Available commands: %s"
                                             % client.commands.keys(),
                       version = "CRAB client v%s" % client.version() )

    parser.add_option("-d", "--debug", dest = "debug", default = False,
                 action  = "store_true", help = "Debug information showed")

    parser.add_option("-v", "--verbose", dest = "verbose", default = True,
                   action  = "store_true", help = "Be verbose in out put")

    # I'm not sure this is a good idea...
    parser.add_option("--detailed-server-interaction", dest = "show_server",
                 default = False, action  = "store_true",
                 help = "Show detailed server interaction, including JSON " + \
                        "sent to/from server. WARNING: Extremely verbose!"
                )

    # by default look for crab_cfg.py file in current working directory
    parser.add_option("-c", "--config", dest = "config",
                      default = './crab_cfg.py',
                      help = "Config file", metavar = "FILE")

    # Auto-generate the options used by commands
    for command in client.commands:
        group = OptionGroup(parser, 'Help for the ' + command + ' command',
                         client.commands[command]['function'].__doc__.strip())
        for option in client.commands[command]['options']:
            # option is a namedtuple('Options',
            #                     'name, short_name, help, default, action')
            # There must be a better way to build this tuple/dict...
            optargs = []
            optkwargs = {}
            if option.name:
                optargs.append('--%s' % option.name)
            if option.short_name:
                optargs.append('-%s' % option.short_name)
            for k, v in option._asdict().items():
                if k not in ['name', 'short_name'] and v:
                    optkwargs[k] = v

            group.add_option(*optargs, **optkwargs)

        parser.add_option_group(group)

    options, args = parser.parse_args()

    # Set up the logger and exception handling

    # Log verbosely
    logger = logging.getLogger('CRAB3')
    logger.setLevel(logging.DEBUG)

    # Set up console output to stdout at appropriate level
    loglevel = logging.WARNING
    if options.verbose:
        loglevel = logging.INFO
    if options.debug:
        loglevel = logging.DEBUG

    console_format = '%(message)s'
    console = logging.StreamHandler(sys.stdout)
    console.setFormatter(logging.Formatter(console_format))
    console.setLevel(loglevel)
    logger.addHandler(console)


    # Replace excepthook with logger
    def log_exception(exc_type, exc_value, tback):
        """
        Send a short version of the exception to the console,
        a long version to the log

        Adapted from Doug Hellmann
        """
        # This goes to the console
        logging.getLogger('CRAB3').error("%s: %s  See logfile for more info" % (exc_type.__name__, exc_value))
        # This goes to the log file
        tbLogger = logging.getLogger('CRAB3:traceback')
        tbLogger.error("Unhandled Exception!")
        tbLogger.error("\tPlease file a bug report at https://svnweb.cern.ch/trac/CMSDMWM/newticket?component=CRABClient with the following information:")
        tbLogger.error("\tClient Version: %s" % client.version())
        tbLogger.error(exc_value, exc_info=(exc_type, exc_value, tback))

    sys.excepthook = log_exception

    # args should be a single element list containing the command to run
    #   e.g. submit, status etc
    # if multiple args are present take the first and ignore the rest
    command, commandoptions = None, {}
    try:
        command = args[0]
        if command in client.commands:
            # if the command isn't known the client handler will raise
            for option in client.commands[command]['options']:
                commandoptions[option.name] = getattr(options, option.name)
    except IndexError:
        logger.critical("You must specify a command to run")
        logger.info("available commands are: %s" % (" ".join(client.commands.keys())))
        logging.getLogger('CRAB3:traceback').exception('Caught exception:')
        sys.exit(1)
    # If we've got this far the user has given a sane set of arguments to
    # the script and we've managed to parse them into something useful:
    #
    # - options are the options specified by switches
    # - command is the command the user wants to run (submit, status etc)
    # - logger is the base logger instance to use
    return options, command, commandoptions, logger


if __name__ == "__main__":
    # Create the crab object and start it
    # Handled in a try/except to run in a controlled environment
    #  - do not want to expose known exception to the outside
    #  - exceptions thrown in the client should exit and set an approprate
    #    exit code, this is a safety net

    client = Handler()
    opt, cmd, cmdoptions, client.logger = getOptionsLogger(client)

    exitcode = 0

    try:
        #if cmd in ['submit']:
        if not os.path.isabs(opt.config):
            opt.config = os.path.abspath(opt.config)
        client.loadConfig(opt.config)
    except ImportError:
        print "Configuration file '%s' not found" % opt.config
        exitcode = 2
    except OSError, oe:
        print "Problem while processing the configuration and creating the workarea: %s " % str(oe)
        exitcode = 2

    if exitcode == 0:
        try:
            exitcode = client(cmd, cmdoptions)
        except KeyError, ke:
            # The single quotes in KeyErrors are annoying...
            logging.getLogger('CRAB3:traceback').exception('Caught exception')
            if str(ke).strip("'") == cmd:
                client.logger.error('%s is an unknown command, run crab -h for available commands' % cmd)
                exitcode = 1
            else:
                # There will be other KeyErrors, catch them here...
                client.logger.error("Error %s" % str(ke))
                exitcode = 100
        except SocketError, se:
            msg = 'Could not establish a connection with the server at %s.\n' % client.configuration.General.server_url
            msg += 'This may be a temporary problem, but if you see it repeatedly please notify AnaOps\n'
            client.logger.error(msg)
            logging.getLogger('CRAB3:traceback').exception('Caught exception')
            exitcode = 2
        except NameError, ne:
            client.logger.error( str(ne) )
            logging.getLogger('CRAB3:traceback').exception('Caught exception')
            exitcode = 3
        except HTTPException, he:
            client.logger.error((" %s (%s): %s" % (he.reason, he.status, json.loads(he.result)['message'])))
            client.logger.debug('Command %s failed with URI: %s' % (cmd, he.url))
            client.logger.debug('     Input data: %s' % he.req_data)
            client.logger.debug('     Request headers: %s' % he.req_headers)
            logging.getLogger('CRAB3:traceback').exception('Caught exception')
            exitcode = he.status

    sys.exit(exitcode)
